1 - docker build -t dockerize_aspcoremvc:v1 .
		dockerize_aspcoremvc : name
		:v1 : tag
		. : Dockerfile path (it is where it runs so .)

2 - docker images
		dockerize_aspcoremvc	v1	1f8	about a minute ago	220MB

3 - docker run -d --name dockerize_aspcoremvc_container -p 5042:80 1f8
		localde 5042 portumdan container içindeki 80 portuna erişim, yoksa appe erişemem
		(varsayılan olarak container içinde 80 portundan çalışıyor -biz önceden port verip oluşturmadığımız için)

		docker run : docker create + docker start + docker attach
		-d : detach > dontt attach  
		--name : container name
		-p : mylocalport:dockerinnerport
		1f8 : first 3 chars of ImageId

	2. bi container daha
		docker run -d --name dockerize_aspcoremvc_container2 -p 5043:80 1f8
		--> c25
4 -  docker rm --force c25
	== docker stop c25 / docker rm c25

--------------------------------------------------------------------------------------------------------------------
.Net CLI : https://learn.microsoft.com/en-US/dotnet/core/tools/  (.Net Core CLI eski)

dotnet build

dotnet run

dotnet publish [path]

etc

Instead of giving published path I can tell to publish inside Dockerfile









######################################### Dockerfile #########################################


FROM mcr.microsoft.com/dotnet/sdk:7.0
WORKDIR /app
COPY . .  => COPY all files and folders where my Dockerfile is   to /app folder I mentioned above where base imge will create on the 1st row
RUN dotnet restore => get all updates on lib/dependencies, or download if nuget pckgs not downloaded etc
RUN dotnet publish Docker_Dockerize.AspNetCoreMvc.csproj -c Release -o out => take csproj all libs are mentioned there, and publish accordingly with mode Release and out them to a folder names out where you will create inside app folder
WORKDIR out => go to out folder we will work there
ENV ASPNETCORE_URLS="http://*:5043" => published local project will run on localhost, container will run it on also localhost, but in the outside world it won't be accessed, container will have to run it on IP, Environment  says it to tun on localhost:5000 (run exe from C:\Users\merve\source\repos\Docker_Dockerize\Docker_Dockerize.AspNetCoreMvc\bin\Release\net7.0\publish to see the env url which is localhost:5000), 
so take whatever IP and run it on port 5043, https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/web-host?view=aspnetcore-7.0
ENTRYPOINT ["dotnet","Docker_Dockerize.AspNetCoreMvc.dll"]


--->>> 
1 - docker build -t dockerize_aspcoremvc:v2 .
2 - docker images
		dockerize_aspcoremvc	v2	bf9	31 seconds ago	831MB
3 - docker run -d --name dockerize_aspcoremvc_container2 -p 5042:5043 bf9
		5042 : MyPort : launchsettings.  "applicationUrl": "https://localhost:7044;http://localhost:5042",
		5053 : DockerPort : Dockerfile.  ENV ASPNETCORE_URLS="http://*:5043"
to run this, I have stopped the prev container which is created from image 1f8 inorder to use 5042 port, since I wanted to run it in on localhost:5042


2nd container
docker run -d --name dockerize_aspcoremvc_container3 -p 5043:5043 bf9

4 - docker ps
dab dockerize_aspcoremvc_container3
218 dockerize_aspcoremvc_container2

5 - docker rm --force dab 218  >>>>> remove 2 containers force(stop and remove)
dab
218



------------------------------------------------------------

Docker MultiStage Build : 1 den fazla base imagedan image oluşturma


# Docker her satır için 1 layer oluşturur
# Docker her layerı cache leyebilir, o layer içerği değişmezse cache den çalışır : hız - performans
# COPY . .  >>> best practice değil onun yerine 1 layer daha ekleyerek performans artışı yapıldı.
# COPY *.csproj . > ile csproj app içine kopyalanıp direk restore edildi ki kodlarda değişiklik varsa onlar restore edilsin, sonra COPY . .  yapıldı ki statiklerde değişen bişey yoksa direk cacheten gelsin. Bu şekilde eğer kodlar değiş de static dosyalar mesela bi css dosya ekledi/değiştirildi - o zaman da copy csproj ve restore direk cacheten çalışır sadece COPY . . normal çalışır - ki performans demek


FROM mcr.microsoft.com/dotnet/sdk:7.0  as build #SDK image
WORKDIR /app
COPY . .
RUN dotnet restore
RUN dotnet publish Docker_Dockerize.AspNetCoreMvc.csproj -c Release -o out

# bu noktada sdk/app/out/publish klasörleri oluştu, ancak sdk image aşırı büyük ve çok yer kaplıyor container oluşturup kaldırmak için aşırı ve gerekisz aslında. Şuan Dockerfile içinde bulunduğumuz noktada sdk gerekli şekilde publish aldı bu dizine, aslında bu publishi alıp sadece runtime image ile yola devam etsek çok daha kullanışlı ve ufak olur.

FROM mcr.microsoft.com/dotnet/aspnet:7.0 #Runtime image
WORKDIR /app # image iine app dizini oluştur
COPY --from=build /app/out .  # yeni image/app dizinine build takma adlı imageı içindeki app/out dizinini al
ENV ASPNETCORE_URLS="http://*:5043"
ENTRYPOINT ["dotnet","Docker_Dockerize.AspNetCoreMvc.dll"]

>>>> docker images
v3 > 220MB >>>> multiStage ile ciddi oranda küçüldü image.. önceki 831di.. SDKdan direk image oluşturma! sdk ile .net cli komutlarından snr runtime ile oluştur!
v2 > 831MB
v1 > 220M


--------------------------
.dockerignore 

COPY . .  > ile herşeyi kopyalıyorduk ama aşağıdaki klasörleri örneğin kopyalamaya gerek yok! o zaman taşımak istemediklerimizi  belirtelim! Dockerfile ile aynı dizine uzantısı yine olmayan .dockerignore dosyası oluşturalım! Dockerfile altına eklenir solutionda.


bin 
obj
Notes 


-->
** ile başlar : iç içe tüm klasörleri ara 
**/bin/ >>>> : iç içe tüm klasörleri ara bin kalsrüne rastlarsan onu alma

**/bin/
**/obj/
**/Dockerfile*    >>>> uzantısı ne olursa olsun Dockerfile isimli olanları alma
**/.dockerignore*

->

Dockerfile ile aşağıdaki son satırlarla zaten publish klasörünü aldığımız için halihazırda .dockerignore içinde belirttiklerimiz zaten gelmiyor ama başka şekilllerde yazsaydık .dockerignore ile bu şekilde boyut küçültüp container hızlandırabilirdik.

FROM mcr.microsoft.com/dotnet/aspnet:7.0
WORKDIR /app
COPY --from=build /app/out . 



------------------------------------------------------------
Docker Volume 

Docker containerlar tarafından üretilen dataları kalıcı kılmamızı sağlayan bir yöntem.


Sorunlar:
------------
1 - Imagedan bir container ayağa kaldırdığımızda image layerlarının en üstüne bir layer ekleniyor, bir data (örneğin bir resim) kaydettiğimiz zaman da bu data en üst layera kaydediliyor.
Container kapatınca/silinince bu layerlar gitti.

2 - 2 ayrı container 2 ayrı bilgisayarda çalışan uygulama gibidir. 2si de birbirlerinin kaydettiği datalrı göremez.

Çözümler :
------------
1 - Bind Mount : OS üzerindeki bir dosyaya containerlar tarafından üretilen dataların kaydedilme işlemi.
	örn: windows üzerinde dockerım var, masaüstünde bir klasör oluştururum ve dockerdaki tüm containerlarım bu dizine data kaydeder.
	2 soruna da çözüm.
2 - Volume :  Docker CLI tarafından yönetilen, OS üzerinde değil, Docker'ın kendi içerisinde bir alanı oluşturması (Docker area). Performaslı
	örn: Docker CLI ile "resimler" diye bir volume oluşturuyoruz, docker içerisinde özel bir alan oluyor ve container datalarını buraya kaydediyoruz.

	Bind Mount vs Volume : 
		- volume direk CLI ile yönetilebiliyor, içinde olduğu için yönetim tamamen Docker'a ait
		- volumeların migrate, backup bindmounta göre çok daha kolay
		- uzak cloud ortamdaki volumelara da container datalarını gönderebiliriz

3 - Tmpfs Mount :  Containerlar tarafından üretilen datalar işletim sistemi üzerinde değil memoryde kaydedilir.

----------------------------------------------------------------------------------
-V Docker volume öncesi
1- resim ekle/görüntüle sonrası image oluştur
docker build --no-cache -t dockerize_aspcoremvc:v1 .   -> d02....
2 - image Id al
docker images
3 - image dan 1. container kaldır
docker run -d --name dockerize_aspcoremvc_container1 -p 5044:5044 d02   -> 818....
4 - image dan 2. container kaldır
docker run -d --name dockerize_aspcoremvc_container2 -p 5045:5044 d02   -> fa8....
sonuç : 
- > containerler birbirinden bağımsız, birinden kaydettiğimiz resmi diğer containerda göremedik ve durdurunda kaydettiğimiz resimler gitti
5 - 2 containerı da sil
docker rm --force 818 fa8   -> 818   fa8
6 - image dan 1 container kaldır
docker run -d --name dockerize_aspcoremvc_container1 -p 5044:5044 d02   -> 070....
7 - localhost:5044 ile bakınca önceden eklenmiş resimlerin gelmedğini gördük. yani eski resimer o containerın inmemorysindeydi . containerı sildim. 


image Id : 691

-> Docker Volume sonrası :  
----------------------------
1 - bind-mount

1 - Docker > Settings > Resources > File Sharing > Share the drive you want to keep files from the containers : C:\
-> C:\Users\merve\OneDrive\Belgeler\Docker Files klasörünü oluşturdum.
2 - docker run -d --name dockerize_aspcoremvc_container1 -p 5044:5044 --mount type=bind,source="C:\Users\merve\OneDrive\Belgeler\docker-files",target="/app/wwwroot/images" 691 
2 - docker run -d --name dockerize_aspcoremvc_container2 -p 5045:5044 --mount type=bind,source="C:\Users\merve\OneDrive\Masaüstü\docker-files",target="/app/wwwroot/images" 691 

--> nedense bende hata veriyor : 
docker: Error respose from daemon: invalid mount config for type"bind" : bind source path does not exist: /run/desktop/mnt/host/c/Users/merve/OneDrive/Belgeler/docker-files
docker: Error respose from daemon: invalid mount config for type"bind" : bind source path does not exist: /run/desktop/mnt/host/c/Users/merve/OneDrive/Masaüstü/docker-files

-->> olsaydı -bu 2 container ayağa kalksaydı - her 2 containerın appından da eklenen dosyalar belirttiğim dizine eklenir, ve bu 2 contaner da birbirinin eklediklerini görürlerdi.

--> bu bind-mount volume tipinde container ayağa kalktığında direk olarak source="C:\Users\merve\OneDrive\Masaüstü\docker-files" klasörünü görüyordu ve öncesinde target="/app/wwwroot/images" klasörümde var olan dosyaları görmedi bile. 

2 - volume : bind-mounta göre daha faydalı, backup, migrate yapılabilir, cloud üzerinde volumelara da kaydedebiliriz.

1 - docker volume create images  -> images dediği an oluştu
docker içinde bir volume oluştur

-v = --volume :  --volume images:/app/wwwroot/images  = images adında bir volume oluştur ve image içindeki /app/wwwroot/images klasöründen başlangıç değerlerini al
2 - docker run -d --name mycon1 -p 5044:5044 --volume images:/app/wwwroot/images 691 -> c7d.. containe rayağa kalktı
docker run -d --name mycon2 -p 5045:5044 --volume images:/app/wwwroot/images 691 -> 992


--> bu volume volume tipinde container ayağa kalktığında direk olarak önce eşleştirmiş olduğumuz klasör ile volume u eşitler, yani  /app/wwwroot/images klasöründe şuan varolan 3 resim dosyasını oluşturulan images volumeına atar.

3 - docker rm 992 c7d --force
volume silme denice containerları silelim öncesinde

4 - docker volume rm images -> images dedi