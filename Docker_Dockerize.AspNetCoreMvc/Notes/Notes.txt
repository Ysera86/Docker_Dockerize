1 - docker build -t dockerize_aspcoremvc:v1 .
		dockerize_aspcoremvc : name
		:v1 : tag
		. : Dockerfile path (it is where it runs so .)

2 - docker images
		dockerize_aspcoremvc	v1	1f8	about a minute ago	220MB

3 - docker run -d --name dockerize_aspcoremvc_container -p 5042:80 1f8
		localde 5042 portumdan container içindeki 80 portuna eriþim, yoksa appe eriþemem
		(varsayýlan olarak container içinde 80 portundan çalýþýyor -biz önceden port verip oluþturmadýðýmýz için)

		docker run : docker create + docker start + docker attach
		-d : detach > dontt attach  
		--name : container name
		-p : mylocalport:dockerinnerport
		1f8 : first 3 chars of ImageId

	2. bi container daha
		docker run -d --name dockerize_aspcoremvc_container2 -p 5043:80 1f8
		--> c25
4 -  docker rm --force c25
	== docker stop c25 / docker rm c25

--------------------------------------------------------------------------------------------------------------------
.Net CLI : https://learn.microsoft.com/en-US/dotnet/core/tools/  (.Net Core CLI eski)

dotnet build

dotnet run

dotnet publish [path]

etc

Instead of giving published path I can tell to publish inside Dockerfile









######################################### Dockerfile #########################################


FROM mcr.microsoft.com/dotnet/sdk:7.0
WORKDIR /app
COPY . .  => COPY all files and folders where my Dockerfile is   to /app folder I mentioned above where base imge will create on the 1st row
RUN dotnet restore => get all updates on lib/dependencies, or download if nuget pckgs not downloaded etc
RUN dotnet publish Docker_Dockerize.AspNetCoreMvc.csproj -c Release -o out => take csproj all libs are mentioned there, and publish accordingly with mode Release and out them to a folder names out where you will create inside app folder
WORKDIR out => go to out folder we will work there
ENV ASPNETCORE_URLS="http://*:5043" => published local project will run on localhost, container will run it on also localhost, but in the outside world it won't be accessed, container will have to run it on IP, Environment  says it to tun on localhost:5000 (run exe from C:\Users\merve\source\repos\Docker_Dockerize\Docker_Dockerize.AspNetCoreMvc\bin\Release\net7.0\publish to see the env url which is localhost:5000), 
so take whatever IP and run it on port 5043, https://andrewlock.net/5-ways-to-set-the-urls-for-an-aspnetcore-app/
https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/web-host?view=aspnetcore-7.0
ENTRYPOINT ["dotnet","Docker_Dockerize.AspNetCoreMvc.dll"]


--->>> 
1 - docker build -t dockerize_aspcoremvc:v2 .
2 - docker images
		dockerize_aspcoremvc	v2	bf9	31 seconds ago	831MB
3 - docker run -d --name dockerize_aspcoremvc_container2 -p 5042:5043 bf9
		5042 : MyPort : launchsettings.  "applicationUrl": "https://localhost:7044;http://localhost:5042",
		5053 : DockerPort : Dockerfile.  ENV ASPNETCORE_URLS="http://*:5043"
to run this, I have stopped the prev container which is created from image 1f8 inorder to use 5042 port, since I wanted to run it in on localhost:5042


2nd container
docker run -d --name dockerize_aspcoremvc_container3 -p 5043:5043 bf9

4 - docker ps
dab dockerize_aspcoremvc_container3
218 dockerize_aspcoremvc_container2

5 - docker rm --force dab 218  >>>>> remove 2 containers force(stop and remove)
dab
218



------------------------------------------------------------

Docker MultiStage Build : 1 den fazla base imagedan image oluþturma


# Docker her satýr için 1 layer oluþturur
# Docker her layerý cache leyebilir, o layer içerði deðiþmezse cache den çalýþýr : hýz - performans
# COPY . .  >>> best practice deðil onun yerine 1 layer daha ekleyerek performans artýþý yapýldý.
# COPY *.csproj . > ile csproj app içine kopyalanýp direk restore edildi ki kodlarda deðiþiklik varsa onlar restore edilsin, sonra COPY . .  yapýldý ki statiklerde deðiþen biþey yoksa direk cacheten gelsin. Bu þekilde eðer kodlar deðiþ de static dosyalar mesela bi css dosya ekledi/deðiþtirildi - o zaman da copy csproj ve restore direk cacheten çalýþýr sadece COPY . . normal çalýþýr - ki performans demek


FROM mcr.microsoft.com/dotnet/sdk:7.0  as build #SDK image
WORKDIR /app
COPY . .
RUN dotnet restore
RUN dotnet publish Docker_Dockerize.AspNetCoreMvc.csproj -c Release -o out

# bu noktada sdk/app/out/publish klasörleri oluþtu, ancak sdk image aþýrý büyük ve çok yer kaplýyor container oluþturup kaldýrmak için aþýrý ve gerekisz aslýnda. Þuan Dockerfile içinde bulunduðumuz noktada sdk gerekli þekilde publish aldý bu dizine, aslýnda bu publishi alýp sadece runtime image ile yola devam etsek çok daha kullanýþlý ve ufak olur.

FROM mcr.microsoft.com/dotnet/aspnet:7.0 #Runtime image
WORKDIR /app # image iine app dizini oluþtur
COPY --from=build /app/out .  # yeni image/app dizinine build takma adlý imageý içindeki app/out dizinini al
ENV ASPNETCORE_URLS="http://*:5043"
ENTRYPOINT ["dotnet","Docker_Dockerize.AspNetCoreMvc.dll"]

>>>> docker images
v3 > 220MB >>>> multiStage ile ciddi oranda küçüldü image.. önceki 831di.. SDKdan direk image oluþturma! sdk ile .net cli komutlarýndan snr runtime ile oluþtur!
v2 > 831MB
v1 > 220M


--------------------------
.dockerignore 

COPY . .  > ile herþeyi kopyalýyorduk ama aþaðýdaki klasörleri örneðin kopyalamaya gerek yok! o zaman taþýmak istemediklerimizi  belirtelim! Dockerfile ile ayný dizine uzantýsý yine olmayan .dockerignore dosyasý oluþturalým! Dockerfile altýna eklenir solutionda.


bin 
obj
Notes 


-->
** ile baþlar : iç içe tüm klasörleri ara 
**/bin/ >>>> : iç içe tüm klasörleri ara bin kalsrüne rastlarsan onu alma

**/bin/
**/obj/
**/Dockerfile*    >>>> uzantýsý ne olursa olsun Dockerfile isimli olanlarý alma
**/.dockerignore*

->

Dockerfile ile aþaðýdaki son satýrlarla zaten publish klasörünü aldýðýmýz için halihazýrda .dockerignore içinde belirttiklerimiz zaten gelmiyor ama baþka þekilllerde yazsaydýk .dockerignore ile bu þekilde boyut küçültüp container hýzlandýrabilirdik.

FROM mcr.microsoft.com/dotnet/aspnet:7.0
WORKDIR /app
COPY --from=build /app/out . 



------------------------------------------------------------
Docker Volume 

Docker containerlar tarafýndan üretilen datalarý kalýcý kýlmamýzý saðlayan bir yöntem.


Sorunlar:
------------
1 - Imagedan bir container ayaða kaldýrdýðýmýzda image layerlarýnýn en üstüne bir layer ekleniyor, bir data (örneðin bir resim) kaydettiðimiz zaman da bu data en üst layera kaydediliyor.
Container kapatýnca/silinince bu layerlar gitti.

2 - 2 ayrý container 2 ayrý bilgisayarda çalýþan uygulama gibidir. 2si de birbirlerinin kaydettiði datalrý göremez.

Çözümler :
------------
1 - Bind Mount : OS üzerindeki bir dosyaya containerlar tarafýndan üretilen datalarýn kaydedilme iþlemi.
	örn: windows üzerinde dockerým var, masaüstünde bir klasör oluþtururum ve dockerdaki tüm containerlarým bu dizine data kaydeder.
	2 soruna da çözüm.
2 - Volume :  Docker CLI tarafýndan yönetilen, OS üzerinde deðil, Docker'ýn kendi içerisinde bir alaný oluþturmasý (Docker area). Performaslý
	örn: Docker CLI ile "resimler" diye bir volume oluþturuyoruz, docker içerisinde özel bir alan oluyor ve container datalarýný buraya kaydediyoruz.

	Bind Mount vs Volume : 
		- volume direk CLI ile yönetilebiliyor, içinde olduðu için yönetim tamamen Docker'a ait
		- volumelarýn migrate, backup bindmounta göre çok daha kolay
		- uzak cloud ortamdaki volumelara da container datalarýný gönderebiliriz

3 - Tmpfs Mount :  Containerlar tarafýndan üretilen datalar iþletim sistemi üzerinde deðil memoryde kaydedilir.

----------------------------------------------------------------------------------
-V Docker volume öncesi
1- resim ekle/görüntüle sonrasý image oluþtur
docker build --no-cache -t dockerize_aspcoremvc:v1 .   -> d02....
2 - image Id al
docker images
3 - image dan 1. container kaldýr
docker run -d --name dockerize_aspcoremvc_container1 -p 5044:5044 d02   -> 818....
4 - image dan 2. container kaldýr
docker run -d --name dockerize_aspcoremvc_container2 -p 5045:5044 d02   -> fa8....
sonuç : 
- > containerler birbirinden baðýmsýz, birinden kaydettiðimiz resmi diðer containerda göremedik ve durdurunda kaydettiðimiz resimler gitti
5 - 2 containerý da sil
docker rm --force 818 fa8   -> 818   fa8
6 - image dan 1 container kaldýr
docker run -d --name dockerize_aspcoremvc_container1 -p 5044:5044 d02   -> 070....
7 - localhost:5044 ile bakýnca önceden eklenmiþ resimlerin gelmedðini gördük. yani eski resimer o containerýn inmemorysindeydi . containerý sildim. 


image Id : 691

-> Docker Volume sonrasý :  
----------------------------
1 - bind-mount

1 - Docker > Settings > Resources > File Sharing > Share the drive you want to keep files from the containers : C:\
-> C:\Users\merve\OneDrive\Belgeler\Docker Files klasörünü oluþturdum.
2 - docker run -d --name dockerize_aspcoremvc_container1 -p 5044:5044 --mount type=bind,source="C:\Users\merve\OneDrive\Belgeler\docker-files",target="/app/wwwroot/images" 691 
2 - docker run -d --name dockerize_aspcoremvc_container2 -p 5045:5044 --mount type=bind,source="C:\Users\merve\OneDrive\Masaüstü\docker-files",target="/app/wwwroot/images" 691 

--> nedense bende hata veriyor : 
docker: Error respose from daemon: invalid mount config for type"bind" : bind source path does not exist: /run/desktop/mnt/host/c/Users/merve/OneDrive/Belgeler/docker-files
docker: Error respose from daemon: invalid mount config for type"bind" : bind source path does not exist: /run/desktop/mnt/host/c/Users/merve/OneDrive/Masaüstü/docker-files

-->> olsaydý -bu 2 container ayaða kalksaydý - her 2 containerýn appýndan da eklenen dosyalar belirttiðim dizine eklenir, ve bu 2 contaner da birbirinin eklediklerini görürlerdi.

--> bu bind-mount volume tipinde container ayaða kalktýðýnda direk olarak source="C:\Users\merve\OneDrive\Masaüstü\docker-files" klasörünü görüyordu ve öncesinde target="/app/wwwroot/images" klasörümde var olan dosyalarý görmedi bile. 

2 - volume : bind-mounta göre daha faydalý, backup, migrate yapýlabilir, cloud üzerinde volumelara da kaydedebiliriz.

1 - docker volume create images  -> images dediði an oluþtu
docker içinde bir volume oluþtur

-v = --volume :  --volume images:/app/wwwroot/images  = images adýnda bir volume oluþtur ve image içindeki /app/wwwroot/images klasöründen baþlangýç deðerlerini al
2 - docker run -d --name mycon1 -p 5044:5044 --volume images:/app/wwwroot/images 691 -> c7d.. containe rayaða kalktý
docker run -d --name mycon2 -p 5045:5044 --volume images:/app/wwwroot/images 691 -> 992


--> bu volume volume tipinde container ayaða kalktýðýnda direk olarak önce eþleþtirmiþ olduðumuz klasör ile volume u eþitler, yani  /app/wwwroot/images klasöründe þuan varolan 3 resim dosyasýný oluþturulan images volumeýna atar.

3 - docker rm 992 c7d --force
volume silme denice containerlarý silelim öncesinde

4 - docker volume rm images -> images dedi

----------------------------------------------------------------------------------

Environment

Asp.net core tarafýnda bir uygulama oluþturunca default olarak 3 environment gelir. Ýstediðimiz kadar ortam oluþturabiliriz. 
Production, Development, Staging

Herhangi bir env belirtilmezse Production env ile, localhostta ise Development ortamýnda ayaða kalkar.

VSde > project > proerties > environment yazýp aratýnca bu projenin VSde hangi ortamda çalýþtýðýmý görebiliriz. Ýstediðimiz eklenebilir. key-value
ASPNETCORE_ENVIRONMENT=Development

--->>>
Viewda environment tagý var, hangi ortamda çalýþýyorsak onun içindeki kodlar çalýþsýn diye. Ortam Development geldi þuan.
<environment names="Development">
    <h1>Ortam Development</h1>
</environment>
<environment names="Production">
    <h1>Ortam Production</h1>
</environment>

Publish edip içinden çalýþtýrýnca da Ortam Production geldi þuan.

docker run -d --name mycon -p 5044:5044 785 -> b0e
containerdan çalýþtýrýnca localhost:5044ten, Ortam Production geldi
docker rm b0e --force -> b0e

Docker içinde otomatik olarak production olur, loglama yoksa hata aldýysak prodda anlaþýlmýyor developmentta görebiliriz, gerekirse development olmasý için :

docker run -d --name mycon -p 5044:5044 --env ASPNETCORE_ENVIRONMENT=DEVELOPMENT  785 -> 5d1     Ortam Development geldi.
--->>>


----------------------------------------------------------------------------------

<none> image
her zaman deðil ama bazen <none> image oluþuyor image oluþtururken, docker bunlarý önbellek -cacheleme- mekanizmasý oluþturmak için kullanýyor. Silmek mantýklý olan

-f : filter,  "dangling=true" <none> image demek
docker images -f "dangling=true"
$(docker images -f "dangling=true" -q) > ImageIDler gelir
docker rmi $(docker images -f "dangling=true" -q)

----------------------------------------------------------------------------------

Container environment :  çok önemli kritik bilgiler appsettingste olmamalý env güvenli

environmentlarý sadece ortam belirlemede deðil appsettings.json içindeki deðiþkenlerini ezmek için de kullanýyoruz

örn:  appsettings.Development.json "MySqlCon": "Local db yolu", ekledik
appsettings.Development.json kopyalayýp appsettings.Production.json oluþturduk ve içine  "MySqlCon": "Uzak sunucu db yolu",  ekledik

-> app deploy edilince appsettings.Production.json da gidecek  ve app ftpsini ele geçirse birisi , bu dosyada da uzan sunucu baðlantý bilgileri kullanýcý adý þifresi vs olsa tam br güvenlik zafiyeti. aslýnda secretkey vs kullanmalýyýz öle olcaksa da, container için bu key-value larý burda tutmaktansa environment olarak belirtebilirz. 

O zaman appsettings.Production.json içinden  "MySqlCon": "Uzak sunucu db yolu",  silmeliyiz. HomeControllerda appsettings okumak için IConfiguration DI ile alýp config içinden MySqlCon okuyup Index. ViewBag.MySqlCon içine alýp yazdýk: _configuration["MySqlCon"]; projenin her yerinde, varsayýlan olarak ÝLK ÖNCE MySqlCon isimli bir ortam deðiþkeni var mý bakar yoksa appsettinge bakar! (env apssettingi ezer). F5 ve Local db yolu yazdý

--env = -e

kod deðiþtiði için yeni image alýp ordan container ile devam etmek gerekli.
docker build -t dockerize_aspcoremvc:v3 .   
docker images -> fe6
docker run -d --name mycon -p 5044:5044 --env MySqlCon='Uzak sunucu db yolu'  fe6 -> 9d3   
	-> çalýþtýrýnca :  Uzak sunucu db yolu     Ortam Production
docker run -d --name myconDev -p 5045:5044 --env ASPNETCORE_ENVIRONMENT=DEVELOPMENT  fe6 -> 03c     
	-> çalýþtýrýnca :  Ortam Development
docker run -d --name myconDevEnv -p 5046:5044 -e ASPNETCORE_ENVIRONMENT=DEVELOPMENT -e MySqlCon='Uzak sunucu db yolu' fe6 -> a63
	-> çalýþtýrýnca :  Uzak sunucu db yolu     Ortam Development

2. yol Dockerfile
ENV ASPNETCORE_URLS="http://*:5044" -> bu hali hazýrda var zaten
ENV MySqlCon="Uzak sunucu db yolu"
ENV ASPNETCORE_ENVIRONMENT="DEVELOPMENT"


----> Çok katmanlý asp core mvc projesi dockerize :  NLayer appten devam bu kýsým



Dokcer kurunca : Docker CLI ve Docker Compose CLI gelir.

Docker Compose 
---------------------------------------------
Micro servis mimarisinde yoðun þekilde kullanýlýyor.
Docker Compose bir tool
YAML formatý :  JSONDan daha sade, {, }yok, girintilerle belirleniyor neyin ne altýnda olduðu.
Settings.json dosyalarý yaml formatýna geçebilir ileride. 

Birden fazla image, birden fazla containerý yönetmeyi saðlar.
Miroservis dünyasýnda tek bir komutla birden fazla mikro servisi kaldýrmak/ durdurmak/silmek için.

Docker compose development amacýyla kullanýlmalý, prod için kubernetes, swarm gibi sistemler kullanmak uygun bir yaklaþýmdýr.

docker version -> 

Docker'ýn 2 versiyonu var:
docker compose version -> v2.19.1  > bu yenisi  -> docker compose
docker-compose-v1.exe version  -> 1.29.2 > bu eskisi   -> docker-compose

docker compose push 
docker compose pull
docker compose up 
docker compose down
start
stop